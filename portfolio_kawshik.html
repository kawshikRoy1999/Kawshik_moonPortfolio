<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Portfolio - Spinning Earth</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        #info-panel {
            position: fixed;
            bottom: 20px;
            width: auto;
            left: 20px;
            background: rgba(0, 20, 40, 0.85);
            color: white;
            padding: 25px;
            border-radius: 15px;
            max-width: 350px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        h1 {
            font-size: 28px;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00d4ff, #0088ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            color: #88c0ff;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        #skill-info {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #skill-info h3 {
            color: #00d4ff;
            margin-bottom: 8px;
            font-size: 18px;
        }
        
        #skill-info p {
            color: #c0d0e0;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .instructions {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 20, 40, 0.85);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 13px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .skill-label {
            position: absolute;
            color: white;
            font-weight: bold;
            font-size: 18px;
            text-align: center;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            user-select: none;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>
    <div id="info-panel">
        <h1>My Portfolio</h1>
        <p class="subtitle">Kawshik Roy : Software Developer</p>
        <p class="subtitle">M.C.A / B.C.A </p>
        <div id="skill-info">
            <p style="color: #88c0ff;">Hover over the skill moons to learn more!</p>
        </div>
    </div>
    <div id="canvas-container"></div>
    
  

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Skills data - customize these with your actual skills!
        const skills = [
            { name: "C#", description: "Strong command over OOP, async programming, and enterprise application development in .NET", color: 0x178600 },
            { name: "ASP.NET", description: "Experience building scalable MVC and WebForms applications with clean architecture", color: 0x512bd4 },
            { name: ".NET Core", description: "Hands-on expertise in building modern, high-performance web applications", color: 0x5c2d91 },
            { name: "Web API", description: "Developed RESTful APIs with authentication, authorization, caching, and Entity Framework", color: 0x1793d1 },
            { name: "ASP.NET MVC", description: "Built dynamic, maintainable MVC applications with strong separation of concerns", color: 0x663399 },
            { name: "SQL Server", description: "Skilled in writing complex queries, stored procedures, indexing, and optimization", color: 0xdb4437 },
            { name: "EF Core", description: "Expertise in code-first, migrations, LINQ queries, and EF Core performance tuning", color: 0x4caf50 },
            { name: "JavaScript", description: "Proficient in ES6+, async/await, DOM manipulation, and API integration", color: 0xf7df1e },
            { name: "jQuery", description: "Experienced in DOM traversal, AJAX operations, event handling, and plugin integration", color: 0x0769ad },
            { name: "React JS", description: "Hands-on experience with component-based architecture, hooks, and state management", color: 0x61dafb },
            { name: "HTML", description: "Skilled in writing clean, semantic, SEO-friendly markup", color: 0xe34c26 },
            { name: "CSS", description: "Good knowledge of responsive design, flexbox, grid, and UI styling", color: 0x264de4 },
            { name: "LINQ", description: "Proficient in querying and transforming data using LINQ to Objects, Entities, and SQL", color: 0x007acc },
            { name: "Bootstrap", description: "Experienced in creating responsive UI layouts and components", color: 0x7952b3 },
            { name: "Chart.js", description: "Implemented interactive charts and data visualization dashboards", color: 0xff6384 },
            { name: "SignalR", description: "Implemented real-time notifications and client-server communication", color: 0x00a3e0 },
            { name: "ADO.NET", description: "Experience in direct database connectivity, transactions, and raw SQL operations", color: 0x8cc84b }
        ];

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000510);
        
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.z = 20;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1.2);
        pointLight.position.set(15, 15, 15);
        scene.add(pointLight);

        const pointLight2 = new THREE.PointLight(0x4488ff, 0.5);
        pointLight2.position.set(-15, -10, -15);
        scene.add(pointLight2);
        
        // --- Central Earth (Portfolio) ---
        const earthGeometry = new THREE.SphereGeometry(3, 10, 64);
        const earthMaterial = new THREE.MeshPhongMaterial({
            color: 0x2233ff,
            emissive: 0x112244,
            shininess: 25,
            specular: 0x333333
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earth);

        // Add atmosphere glow
        const atmosphereGeometry = new THREE.SphereGeometry(3.3, 64, 64);
        const atmosphereMaterial = new THREE.MeshBasicMaterial({
            color: 0x4488ff,
            transparent: true,
            opacity: 0.15,
            side: THREE.BackSide
        });
        const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
        scene.add(atmosphere);
        
        // Group for Moons (Skills)
        const moons = [];
        const moonLabels = [];
        const moonGroup = new THREE.Group();
        scene.add(moonGroup);

        skills.forEach((skill, index) => {
            // --- 1. Calculate Orbit Parameters ---
            const totalSkills = skills.length;
            const minRadius = 6.5; 
            const maxRadius = 11.5; 
            
            // Calculate a unique radius for this skill
            const radius = minRadius + (index / totalSkills) * (maxRadius - minRadius);
            
            // Initial angle spread out
            const initialAngle = (index / totalSkills) * Math.PI * 2;
            
            // Calculate a unique rotational speed
            const speed = 0.05 + index * 0.005; 

            // Calculate a unique vertical offset and frequency for a complex path
            const heightOffset = Math.sin(index) * 0.5;
            const verticalFrequency = 2 + (index % 3);

            // --- 2. Create the Skill Moon ---
            const moonGeometry = new THREE.SphereGeometry(0.6, 32, 32);
            const moonMaterial = new THREE.MeshPhongMaterial({
                color: skill.color,
                emissive: skill.color,
                emissiveIntensity: 0.3,
                shininess: 100
            });
            const moon = new THREE.Mesh(moonGeometry, moonMaterial);
            
            // Store orbital data directly on the moon
            moon.userData = { 
                skill: skill, 
                angle: initialAngle, 
                radius: radius, 
                speed: speed,
                heightOffset: heightOffset,
                verticalFrequency: verticalFrequency
            };
            
            // Set initial position
            moon.position.x = Math.cos(initialAngle) * radius;
            moon.position.z = Math.sin(initialAngle) * radius;
            moon.position.y = heightOffset + Math.sin(initialAngle * verticalFrequency) * 1.5;

            // Add glow
            const glowGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: skill.color,
                transparent: true,
                opacity: 0.2
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            moon.add(glow);
            
            moonGroup.add(moon);
            moons.push(moon);
            
            // --- Path creation code removed here ---

            // --- 3. Create HTML label ---
            const label = document.createElement('div');
            label.className = 'skill-label';
            label.textContent = skill.name;
            label.style.color = '#' + skill.color.toString(16).padStart(6, '0');
            document.body.appendChild(label);
            moonLabels.push(label);
        });

        // Stars background
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.1,
            transparent: true,
            opacity: 0.8
        });

        const starsVertices = [];
        for (let i = 0; i < 3000; i++) {
            const x = (Math.random() - 0.5) * 200;
            const y = (Math.random() - 0.5) * 200;
            const z = (Math.random() - 0.5) * 200;
            starsVertices.push(x, y, z);
        }

        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Raycaster for mouse interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredMoon = null;

        // Mouse move handler
        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(moons); 

            // Reset previous hover
            if (hoveredMoon) {
                hoveredMoon.material.emissiveIntensity = 0.3;
                hoveredMoon.scale.set(1, 1, 1);
            }

            if (intersects.length > 0) {
                hoveredMoon = intersects[0].object;
                hoveredMoon.material.emissiveIntensity = 0.8;
                hoveredMoon.scale.set(1.3, 1.3, 1.3);
                
                // Update info panel
                const skill = hoveredMoon.userData.skill;
                document.getElementById('skill-info').innerHTML = `
                    <h3>${skill.name}</h3>
                    <p>${skill.description}</p>
                `;
                
                document.body.style.cursor = 'pointer';
            } else {
                hoveredMoon = null;
                // Only reset info panel if a moon isn't currently hovered
                if (!hoveredMoon) {
                    document.getElementById('skill-info').innerHTML = `
                        <p style="color: #88c0ff;">Hover over the skill moons to learn more!</p>
                    `;
                }
                document.body.style.cursor = 'default';
            }
        }

        window.addEventListener('mousemove', onMouseMove);

        // Mouse controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });

        renderer.domElement.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;
                
                // Rotate the moon group
                moonGroup.rotation.y += deltaX * 0.01;
                moonGroup.rotation.x += deltaY * 0.01;

                // Clamp X rotation to prevent the scene from flipping over
                const clampValue = Math.PI / 2;
                moonGroup.rotation.x = Math.max(-clampValue, Math.min(clampValue, moonGroup.rotation.x));
                
                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        });

        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Zoom with mouse wheel
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = Math.max(10, Math.min(30, camera.position.z));
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Function to update label positions
        function updateLabels() {
            moons.forEach((moon, index) => {
                const vector = new THREE.Vector3();
                moon.getWorldPosition(vector); 
                vector.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
                
                const label = moonLabels[index];
                label.style.left = x + 'px';
                label.style.top = (y - 40) + 'px';
                
                // Hide labels that are behind the camera (vector.z > 1)
                if (vector.z > 1) {
                    label.style.display = 'none';
                } else {
                    label.style.display = 'block';
                    // Adjust opacity based on distance from the camera center
                    const opacity = 1 - Math.abs(vector.z);
                    label.style.opacity = Math.max(0.3, opacity);
                }
            });
        }

        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Rotate Earth
            earth.rotation.y += 0.002;
            
            // Rotate atmosphere slowly
            atmosphere.rotation.y += 0.001;

            // Animate moons in orbit with unique speed
            moons.forEach((moon) => {
                const { angle, radius, speed, heightOffset, verticalFrequency } = moon.userData;
                
                // Use a dynamic angle calculation based on time and unique speed
                const newAngle = angle + time * speed;
                
                // Calculate new position based on unique radius and angle
                moon.position.x = Math.cos(newAngle) * radius;
                moon.position.z = Math.sin(newAngle) * radius;
                // Add vertical movement for a more complex, non-planar path
                moon.position.y = heightOffset + Math.sin(newAngle * verticalFrequency) * 1.5; 
                
                // Moons self-rotate
                moon.rotation.y += 0.02;
            });

            // Gentle camera sway if not dragging
            if (!isDragging) {
                camera.position.x = Math.sin(time * 0.1) * 2;
                camera.position.y = Math.cos(time * 0.15) * 1;
                camera.lookAt(scene.position);
            }

            // Rotate stars slowly
            stars.rotation.y += 0.0001;

            // Update label positions
            updateLabels();

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>